# Challenges Algoritmia

This repository contains optimized Java solutions for LeetCode algorithm problems, organized according to a 6-week study plan.

## ğŸ“ Directory Structure

```
challenges-algoritmia/
â”œâ”€â”€ semana_1/          # Week 1: Arrays and Strings (basic)
â”œâ”€â”€ semana_2/          # Week 2: HashMap and Sets
â”œâ”€â”€ semana_3/          # Week 3: Stacks and Queues
â”œâ”€â”€ semana_4/          # Week 4: Trees and Recursion
â”œâ”€â”€ semana_5/          # Week 5: Sorting & Sliding Window
â”œâ”€â”€ semana_6/          # Week 6: Dynamic Programming (Basic)
â””â”€â”€ problemas_adicionales/  # Additional problems
```

Each problem file includes:
- Problem description (English)
- Solution approach explanation
- Time and space complexity (Big O)
- Unit tests in `main` method

## ğŸ“š Index by Week

### âœ… Week 1: Arrays and Strings (Basic)
**Objective:** Get familiar with array manipulation, strings, and basic operations.

| Problem | Status | Topic | File |
|---------|--------|-------|------|
| [217 - Contains Duplicate](semana_1/217_contains_duplicate.java) | âœ… Completed | HashSet + Arrays | `semana_1/217_contains_duplicate.java` |
| [344 - Reverse String](semana_1/344_reverse_string.java) | âœ… Completed | Two Pointers | `semana_1/344_reverse_string.java` |
| [1 - Two Sum](semana_1/1_two_sum.java) | âœ… Completed | HashMap + Search | `semana_1/1_two_sum.java` |
| [242 - Valid Anagram](semana_1/242_valid_anagram.java) | âœ… Completed | HashMap / Char Array | `semana_1/242_valid_anagram.java` |
| [Binary Search - NÃºmeros Pares](semana_1/binary_search_numeros_pares.java) | âœ… Completed | Binary Search | `semana_1/binary_search_numeros_pares.java` |
| [Detectar Primer Caracter Duplicado](semana_1/detectar_primer_caracter_duplicado.java) | âœ… Completed | HashSet + Traversal | `semana_1/detectar_primer_caracter_duplicado.java` |
| [125 - Valid Palindrome](semana_1/125_valid_palindrome.java) | âœ… Completed | Two Pointers + Logic | `semana_1/125_valid_palindrome.java` |
| [20 - Valid Parentheses](semana_1/20_valid_parentheses.java) | âœ… Completed | Stack | `semana_1/20_valid_parentheses.java` |

### âœ… Week 2: HashMap and Sets
**Objective:** Deepen understanding of key structures for efficient searches and counting.

| Problem | Status | Topic | File |
|---------|--------|-------|------|
| [49 - Group Anagrams](semana_2/49_group_anagrams.java) | âœ… Completed | HashMap with Lists | `semana_2/49_group_anagrams.java` |
| [347 - Top K Frequent Elements](semana_2/347_top_k_frequent_elements.java) | âœ… Completed | HashMap + PriorityQueue | `semana_2/347_top_k_frequent_elements.java` |
| [36 - Valid Sudoku](semana_2/36_valid_sudoku.java) | âœ… Completed | Set Validation | `semana_2/36_valid_sudoku.java` |
| [202 - Happy Number](semana_2/202_happy_number.java) | âœ… Completed | Cycle Detection with Set | `semana_2/202_happy_number.java` |
| [205 - Isomorphic Strings](semana_2/205_isomorphic_strings.java) | âœ… Completed | HashMap + Bi-mapping | `semana_2/205_isomorphic_strings.java` |
| [128 - Longest Consecutive Sequence](semana_2/128_longest_consecutive_sequence.java) | âœ… Completed | Set + Optimization | `semana_2/128_longest_consecutive_sequence.java` |
| [1636 - Sort Array by Increasing Frequency](semana_2/1636_sort_array_by_increasing_frequency.java) | âœ… Completed | HashMap + Sorting | `semana_2/1636_sort_array_by_increasing_frequency.java` |

### âœ… Week 3: Stacks and Queues
**Objective:** Learn LIFO/FIFO structures for sequential problems.

| Problem | Status | Topic | File |
|---------|--------|-------|------|
| [155 - Min Stack](semana_3/155_min_stack.java) | âœ… Completed | Stack with State | `semana_3/155_min_stack.java` |
| [20 - Valid Parentheses](semana_3/20_valid_parentheses.java) | âœ… Completed | Stack | `semana_3/20_valid_parentheses.java` |
| [739 - Daily Temperatures](semana_3/739_daily_temperatures.java) | âœ… Completed | Stack + Indices | `semana_3/739_daily_temperatures.java` |
| [232 - Implement Queue using Stacks](semana_3/232_implement_queue_using_stacks.java) | âœ… Completed | Stack/Queue Simulation | `semana_3/232_implement_queue_using_stacks.java` |
| [150 - Evaluate Reverse Polish Notation](semana_3/150_evaluate_reverse_polish_notation.java) | âœ… Completed | Stack Math | `semana_3/150_evaluate_reverse_polish_notation.java` |

### âœ… Week 4: Trees and Recursion
**Objective:** Understand hierarchical structures and recursion.

| Problem | Status | Topic | File |
|---------|--------|-------|------|
| [104 - Maximum Depth of Binary Tree](semana_4/104_maximum_depth_of_binary_tree.java) | âœ… Completed | Recursive DFS | `semana_4/104_maximum_depth_of_binary_tree.java` |
| [226 - Invert Binary Tree](semana_4/226_invert_binary_tree.java) | âœ… Completed | Recursion | `semana_4/226_invert_binary_tree.java` |
| [543 - Diameter of Binary Tree](semana_4/543_diameter_of_binary_tree.java) | âœ… Completed | Recursion with State | `semana_4/543_diameter_of_binary_tree.java` |
| [236 - Lowest Common Ancestor](semana_4/236_lowest_common_ancestor.java) | âœ… Completed | Recursion | `semana_4/236_lowest_common_ancestor.java` |
| [101 - Symmetric Tree](semana_4/101_symmetric_tree.java) | âœ… Completed | Recursion + Mirror | `semana_4/101_symmetric_tree.java` |

### âœ… Week 5: Sorting & Sliding Window
**Objective:** Apply sliding windows and sorting techniques.

| Problem | Status | Topic | File |
|---------|--------|-------|------|
| [56 - Merge Intervals](problemas_adicionales/56_merge_intervals.java) | âœ… Completed | Sorting | `problemas_adicionales/56_merge_intervals.java` |
| [57 - Insert Interval](semana_5/57_insert_interval.java) | âœ… Completed | Sorting + Logic | `semana_5/57_insert_interval.java` |
| [239 - Sliding Window Maximum](semana_5/239_sliding_window_maximum.java) | âœ… Completed | Deque + Window | `semana_5/239_sliding_window_maximum.java` |
| [3 - Longest Substring Without Repeating Characters](semana_5/3_longest_substring_without_repeating_characters.java) | âœ… Completed | Sliding Window + Set | `semana_5/3_longest_substring_without_repeating_characters.java` |
| [76 - Minimum Window Substring](semana_5/76_minimum_window_substring.java) | âœ… Completed | Sliding Window + Map | `semana_5/76_minimum_window_substring.java` |

### âœ… Week 6: Dynamic Programming (Basic)
**Objective:** Introduction to subproblems and memoization/tabulation.

| Problem | Status | Topic | File |
|---------|--------|-------|------|
| [70 - Climbing Stairs](semana_6/70_climbing_stairs.java) | âœ… Completed | Basic DP (Fibonacci) | `semana_6/70_climbing_stairs.java` |
| [198 - House Robber](semana_6/198_house_robber.java) | âœ… Completed | 1D DP | `semana_6/198_house_robber.java` |
| [322 - Coin Change](semana_6/322_coin_change.java) | âœ… Completed | DP with Minimums | `semana_6/322_coin_change.java` |
| [5 - Longest Palindromic Substring](semana_6/5_longest_palindromic_substring.java) | âœ… Completed | DP + Strings | `semana_6/5_longest_palindromic_substring.java` |
| [53 - Maximum Subarray](semana_6/53_maximum_subarray.java) | âœ… Completed | Kadane's Algorithm | `semana_6/53_maximum_subarray.java` |

### ğŸ“¦ Additional Problems

| Problem | Status | Topic | File |
|---------|--------|-------|------|
| [2043 - Simple Bank System](problemas_adicionales/2043_simple_bank_system.java) | âœ… Completed | System Design | `problemas_adicionales/2043_simple_bank_system.java` |
| [3161 - Block Placement Queries](problemas_adicionales/3161_block_placement_queries.java) | âœ… Completed | Binary Search | `problemas_adicionales/3161_block_placement_queries.java` |
| [3045 - Count Prefix and Suffix Pairs II](problemas_adicionales/3045_count_prefix_and_suffix_pairs_ii.java) | âœ… Completed | String Matching | `problemas_adicionales/3045_count_prefix_and_suffix_pairs_ii.java` |
| [3071 - Minimum Operations to Write the Letter Y](problemas_adicionales/3071_minimum_operations_to_write_letter_y.java) | âœ… Completed | Grid Manipulation | `problemas_adicionales/3071_minimum_operations_to_write_letter_y.java` |
| [2768 - Number of Black Blocks](problemas_adicionales/2768_number_of_black_blocks.java) | âœ… Completed | Counting | `problemas_adicionales/2768_number_of_black_blocks.java` |
| [723 - Candy Crush](problemas_adicionales/723_candy_crush.java) | âœ… Completed | Simulation | `problemas_adicionales/723_candy_crush.java` |
| [84 - Largest Rectangle in Histogram](problemas_adicionales/84_largest_rectangle_in_histogram.java) | âœ… Completed | Monotonic Stack | `problemas_adicionales/84_largest_rectangle_in_histogram.java` |
| [2672 - Number of Adjacent Elements With the Same Color](problemas_adicionales/2672_number_of_adjacent_elements_with_same_color.java) | âœ… Completed | Array Manipulation | `problemas_adicionales/2672_number_of_adjacent_elements_with_same_color.java` |
| [3034 - Number of Subarrays That Match a Pattern I](problemas_adicionales/3034_number_of_subarrays_that_match_pattern_i.java) | âœ… Completed | Pattern Matching | `problemas_adicionales/3034_number_of_subarrays_that_match_pattern_i.java` |
| [1861 - Rotating the Box](problemas_adicionales/1861_rotating_the_box.java) | âœ… Completed | Matrix Rotation | `problemas_adicionales/1861_rotating_the_box.java` |
| [71 - Simplify Path](problemas_adicionales/71_simplify_path.java) | âœ… Completed | Stack | `problemas_adicionales/71_simplify_path.java` |
| [146 - LRU Cache](problemas_adicionales/146_lru_cache.java) | âœ… Completed | Data Structure | `problemas_adicionales/146_lru_cache.java` |
| [54 - Spiral Matrix](problemas_adicionales/54_spiral_matrix.java) | âœ… Completed | Matrix Traversal | `problemas_adicionales/54_spiral_matrix.java` |
| [68 - Text Justification](problemas_adicionales/68_text_justification.java) | âœ… Completed | String Formatting | `problemas_adicionales/68_text_justification.java` |
	| [332 - Reconstruct Itinerary](problemas_adicionales/332_reconstruct_itinerary.java) | âœ… Completed | Graph DFS | `problemas_adicionales/332_reconstruct_itinerary.java` |

**Total: 50 problems solved**

## ğŸ§  Systematic Playbook by Algorithmic Pattern
To systematize the problem-solving approach, problems are categorized by common algorithmic patterns (inspired by *Grokking the Coding Interview*). Each pattern includes clues on how to identify when to apply it.

### 1. Two Pointers
**ğŸ’¡ How to identify:** Array or string is sorted (or you are searching for pairs). You need to find a set of elements that fulfill certain constraints, or do in-place swaps/comparisons from both ends.
**ğŸ› ï¸ Pattern / Template:** Initialize `left = 0` and `right = array.length - 1`. Use a `while (left < right)` loop and move the pointers inwards based on conditions.
**âš ï¸ Consejo / Tip:** Si el array no estÃ¡ ordenado, considera si puedes ordenarlo primero ($O(N \log N)$) sin romper los requisitos del problema.
- [1 - Two Sum](semana_1/1_two_sum.java) *(Using Hash Map for O(1) lookup)*
- [125 - Valid Palindrome](semana_1/125_valid_palindrome.java) *(Opposite direction)*
- [344 - Reverse String](semana_1/344_reverse_string.java) *(Opposite direction)*
- [1861 - Rotating the Box](problemas_adicionales/1861_rotating_the_box.java) *(Simulating gravity with two pointers)*

### 2. Fast & Slow Pointers (Cycle Detection)
**ğŸ’¡ How to identify:** Problems involving linked lists, arrays, or sequences where you need to find a cycle, the middle element, or a specific mathematical loop.
**ğŸ› ï¸ Pattern / Template:** Initialize `slow = head` and `fast = head`. Move `slow` by 1 step and `fast` by 2 steps. If they ever meet, there is a cycle.
**âš ï¸ Consejo / Tip:** Utiliza este patrÃ³n siempre que veas problemas que hablan sobre "infinito", "encontrar repeticiones cÃ­clicas" o "encontrar la mitad" en una linked list con $O(1)$ de espacio extra.
- [202 - Happy Number](semana_2/202_happy_number.java) *(Floydâ€™s Cycle-Finding Algorithm)*

### 3. Sliding Window
**ğŸ’¡ How to identify:** The problem asks for the longest/shortest substring, subarray, or a desired value over a *contiguous* sequence of elements.
**ğŸ› ï¸ Pattern / Template:** Use a `left` and `right` pointer. Expand the window by moving `right`. When the condition breaks, shrink the window by moving `left` until valid again.
**âš ï¸ Consejo / Tip:** La clave del Sliding Window es preguntarse repetitivamente durante la iteraciÃ³n: "Â¿CuÃ¡ndo es vÃ¡lida mi ventana y cuÃ¡ndo debo encogerla haciendo avanzar el puntero `left`?".
- [3 - Longest Substring Without Repeating Characters](semana_5/3_longest_substring_without_repeating_characters.java) *(Variable window)*
- [76 - Minimum Window Substring](semana_5/76_minimum_window_substring.java) *(Variable window + HashMap)*
- [239 - Sliding Window Maximum](semana_5/239_sliding_window_maximum.java) *(Fixed window + Monotonic Deque)*

### 4. Merge Intervals (Sweep Line)
**ğŸ’¡ How to identify:** Problems involving mutually exclusive intervals, overlapping schedules, or merging ranges. Usually requires sorting the intervals first.
**ğŸ› ï¸ Pattern / Template:** Sort intervals by start time. Iterate through, comparing the current interval's start with the previous interval's end point.
**âš ï¸ Consejo / Tip:** Siempre ordena por el tiempo de inicio (`intervals[i][0]`). Si `current.start <= previous.end`, hay solapamiento y debes fusionar ambos actualizando el lÃ­mite superior (`end = Math.max(previous.end, current.end)`).
- [56 - Merge Intervals](problemas_adicionales/56_merge_intervals.java)
- [57 - Insert Interval](semana_5/57_insert_interval.java)

### 5. Hashing & Frequency Counting (Lookup Maps)
**ğŸ’¡ How to identify:** You need $O(1)$ lookups, need to count frequencies to detect anagrams/duplicates, or need to map relationships between two datasets.
**ğŸ› ï¸ Pattern / Template:** Use `HashMap<Key, Value>` for counting/mapping or `HashSet<Type>` to detect presence/duplicates.
**âš ï¸ Consejo / Tip:** En Java, cuidado con comparar objetos clave (usa `.equals()`). Si los valores son solo letras de la 'a' a la 'z', usar un array de conteos fijo (`int[] count = new int[26]`) es siempre mucho mÃ¡s rÃ¡pido que un `HashMap`.
- [49 - Group Anagrams](semana_2/49_group_anagrams.java)
- [242 - Valid Anagram](semana_1/242_valid_anagram.java)
- [217 - Contains Duplicate](semana_1/217_contains_duplicate.java)
- [Detectar Primer Caracter Duplicado](semana_1/detectar_primer_caracter_duplicado.java)
- [128 - Longest Consecutive Sequence](semana_2/128_longest_consecutive_sequence.java) *(HashSet for O(1) sequence building)*
- [36 - Valid Sudoku](semana_2/36_valid_sudoku.java) *(State Hashing)*
- [205 - Isomorphic Strings](semana_2/205_isomorphic_strings.java) *(Bi-directional Mapping)*
- [1636 - Sort Array by Increasing Frequency](semana_2/1636_sort_array_by_increasing_frequency.java)

### 6. Modified Binary Search
**ğŸ’¡ How to identify:** The input is sorted (or rotated/partially sorted), and the problem requires $O(\log N)$ time complexity.
**ğŸ› ï¸ Pattern / Template:** `left = 0`, `right = n - 1`. Core loop `while(left <= right)`, calculate `mid = left + (right - left) / 2`.
**âš ï¸ Consejo / Tip:** SIEMPRE calcula `mid` como `left + (right - left) / 2` para evitar Integer Overflows si el array es enorme. Piensa bien si el "while" debe ser `<=` o `<`, dependiendo si buscas un Ã­ndice exacto o un lÃ­mite.
- [Binary Search - NÃºmeros Pares](semana_1/binary_search_numeros_pares.java)
- [3161 - Block Placement Queries](problemas_adicionales/3161_block_placement_queries.java)

### 7. Tree DFS (Depth-First Search)
**ğŸ’¡ How to identify:** You need to search tree nodes, find the deepest path, check symmetric properties, or evaluate from leaves back to the root (Bottom-up or Top-down).
**ğŸ› ï¸ Pattern / Template:** Recursive function `dfs(TreeNode node)`. Base case: `if (node == null) return ...`. Recursive calls to `dfs(node.left)` and `dfs(node.right)`.
**âš ï¸ Consejo / Tip:** Determina cuÃ¡l es la secuencia lÃ³gica que necesitas: Â¿Ejecutar antes (Pre-order), en el medio (In-order) o despuÃ©s (Post-order) de visitar a los hijos? El Post-order es vital cuando un nodo padre necesita la respuesta calculada de sus hijos.
- [104 - Maximum Depth of Binary Tree](semana_4/104_maximum_depth_of_binary_tree.java)
- [226 - Invert Binary Tree](semana_4/226_invert_binary_tree.java)
- [543 - Diameter of Binary Tree](semana_4/543_diameter_of_binary_tree.java)
- [236 - Lowest Common Ancestor](semana_4/236_lowest_common_ancestor.java)
- [101 - Symmetric Tree](semana_4/101_symmetric_tree.java)

### 8. Stack & Monotonic Stack
**ğŸ’¡ How to identify:** 
  - *Classic:* You need to parse nested structures (parentheses, paths) or reverse operations (LIFO). 
  - *Monotonic:* You need to find the "next greater" or "next smaller" element efficiently.
**ğŸ› ï¸ Pattern / Template:** Usa un loop for clÃ¡sico con un `stack.push()`. Para el stack monÃ³tono, el cÃ³digo base es: `while (!stack.isEmpty() && current > array[stack.peek()]) { stack.pop(); }`.
**âš ï¸ Consejo / Tip:** Utiliza la interfaz `Deque` (implementada por `ArrayDeque`) en Java moderno. La antigua clase `Stack` es asÃ­ncrona y mÃ¡s lenta (Synchronized). En los Stacks MonÃ³tonos casi siempre vas a guardar *los Ã­ndices* de las posiciones, no los valores del array.
- **Classic Parsing:**
  - [20 - Valid Parentheses](semana_1/20_valid_parentheses.java)
  - [150 - Evaluate Reverse Polish Notation](semana_3/150_evaluate_reverse_polish_notation.java)
  - [71 - Simplify Path](problemas_adicionales/71_simplify_path.java)
- **Monotonic Sequence:**
  - [739 - Daily Temperatures](semana_3/739_daily_temperatures.java)
  - [84 - Largest Rectangle in Histogram](problemas_adicionales/84_largest_rectangle_in_histogram.java)
- **Queue/Stack Architecture:**
  - [155 - Min Stack](semana_3/155_min_stack.java)
  - [232 - Implement Queue using Stacks](semana_3/232_implement_queue_using_stacks.java)

### 9. Top 'K' Elements (Heaps / Priority Queue)
**ğŸ’¡ How to identify:** The problem asks to find the top/smallest/frequent 'K' elements in an array.
**ğŸ› ï¸ Pattern / Template:** Define una `PriorityQueue` de tamaÃ±o `K`. Haz insert (`pq.add(val)`). Si la cola excede el tamaÃ±o K (`pq.size() > K`), haz un poll (`pq.poll()`).
**âš ï¸ Consejo / Tip:** Para "Los K MAYORES", usa un Min-Heap de tamaÃ±o K (mantienes solo los mÃ¡s fuertes dentro y siempre eliminas el mÃ¡s dÃ©bil en la base del root). Para "Los K MENORES", haz a la inversa y usa un Max-Heap.
- [347 - Top K Frequent Elements](semana_2/347_top_k_frequent_elements.java)

### 10. Graph Traversal (DFS/BFS)
**ğŸ’¡ How to identify:** Problems modeled explicitly as networks, connections, or finding a path between states (Eulerian paths, shortest reach).
**ğŸ› ï¸ Pattern / Template:** Utiliza siempre una "Lista de Adyacencia" (`Map<Node, List<Node>>`). Usa un `HashSet<Node>` adicional para llevar control de los `visited` y no quedar en un bucle infinito si hay ciclos.
**âš ï¸ Consejo / Tip:** Si el problema te exige encontrar "EL CAMINO MÃS CORTO", **BFS (Queue)** es mandatorio. Si la meta es exploraciÃ³n total o backtracking buscando una sola respuesta final vÃ¡lida, utiliza **DFS (Recursivo/Stack)**.
- [332 - Reconstruct Itinerary](problemas_adicionales/332_reconstruct_itinerary.java) *(Hierholzer's Algorithm)*

### 11. Dynamic Programming (1D & Strings)
**ğŸ’¡ How to identify:** The problem asks for the max/min/longest value, involves making choices at each step, and has overlapping subproblems (you can memoize past results).
**ğŸ› ï¸ Pattern / Template:** Identify the state variable (index). Initialize memory `dp[]`. Define the Base cases `dp[0]` y `dp[1]`. Find the mathematical Transition Recurrence relation: e.g., `dp[i] = Math.max(dp[i-1], dp[i-2] + current)`.
**âš ï¸ Consejo / Tip:** Antes de programar Â¡dibuja a mano el Ã¡rbol recursivo!. Cuando veas la repetitividad visualmente, aplica MemoizaciÃ³n (Top-Down con un Dictionary). Solo despuÃ©s pÃ¡salo a TabulaciÃ³n si te solicitan optimizar a O(1) el espacio.
- [70 - Climbing Stairs](semana_6/70_climbing_stairs.java) *(Fibonacci pattern)*
- [198 - House Robber](semana_6/198_house_robber.java) *(1D Decision DP)*
- [322 - Coin Change](semana_6/322_coin_change.java) *(Unbounded Knapsack)*
- [53 - Maximum Subarray](semana_6/53_maximum_subarray.java) *(Kadane's Algorithm)*
- [5 - Longest Palindromic Substring](semana_6/5_longest_palindromic_substring.java) *(Expand around center DP)*

### 12. Trie (Prefix Tree) & Advanced String Matching
**ğŸ’¡ How to identify:** The problem involves a dictionary of words, checking prefixes, or specific substring mathematical matching.
**ğŸ› ï¸ Pattern / Template:** Create a inner `TrieNode` class storing `TrieNode[] children = new TrieNode[26];` and a boolean termination marker `boolean isEndOfWord = false;`.
**âš ï¸ Consejo / Tip:** Un Ã¡rbol Trie brilla cuando necesitamos recuperar palabras o validar prefijos y la complejidad queremos que dependa exclusivamente de $O(L)$ (Longitud de la palabra a buscar) e ignorar los miles o millones de palabras del diccionario principal.
- [3045 - Count Prefix and Suffix Pairs II](problemas_adicionales/3045_count_prefix_and_suffix_pairs_ii.java) *(Trie structure)*
- [3034 - Number of Subarrays That Match a Pattern I](problemas_adicionales/3034_number_of_subarrays_that_match_pattern_i.java)
- [68 - Text Justification](problemas_adicionales/68_text_justification.java) *(String simulation)*

### 13. Matrix Traversal & Simulation
**ğŸ’¡ How to identify:** You must navigate a 2D grid in a specific pattern, apply game logic (gravity, matches), or rotate elements without extra space.
**ğŸ› ï¸ Pattern / Template:** Para travesÃ­as, establece el "direction array": `int[][] dirs = {{0,1}, {1,0}, {0,-1}, {-1,0}}`. Calculate potential moves using `nextR = currentR + dirs[x][0]`.
**âš ï¸ Consejo / Tip:** Evita un `IndexOutOfBoundsException` y encapsula la validaciÃ³n de grid en un if aparte siempre: `if(nextR >= 0 && nextR < R && nextC >= 0 && nextC < C)`. En juegos de gravedad iterativa actÃºa "Columna por columna", simulando piezas que caen o desplazando punteros.
- [54 - Spiral Matrix](problemas_adicionales/54_spiral_matrix.java) *(Layer iteration)*
- [3071 - Minimum Operations to Write the Letter Y](problemas_adicionales/3071_minimum_operations_to_write_letter_y.java)
- [723 - Candy Crush](problemas_adicionales/723_candy_crush.java) *(State mutation & Gravity)*
- [2768 - Number of Black Blocks](problemas_adicionales/2768_number_of_black_blocks.java)
- [2672 - Number of Adjacent Elements With the Same Color](problemas_adicionales/2672_number_of_adjacent_elements_with_same_color.java)

### 14. Architecture & Design Systems
**ğŸ’¡ How to identify:** You are asked to implement a class with custom specific data structure properties combined.
**ğŸ› ï¸ Pattern / Template:** Wrap variables with private. Use HashMap to pair keys exactly to TreeNodes or List Nodes pointers for immediate direct O(1) manipulation of arbitrary items.
**âš ï¸ Consejo / Tip:** Hay una mÃ¡xima dorada de diseÃ±o de algoritmos para entrevistas: Cuando necesitas **acceso en $O(1)$ y control cronolÃ³gico o de frecuencias de uso**, la combinaciÃ³n requerida es siempre un `HashMap` +  `Doubly Linked List`.
- [146 - LRU Cache](problemas_adicionales/146_lru_cache.java) *(Doubly Linked List + HashMap)*
- [2043 - Simple Bank System](problemas_adicionales/2043_simple_bank_system.java)

## ğŸš€ Execution

### Run a single problem

```bash
# Compile
javac semana_X/problem_name.java

# Run (with tests)
java -ea ProblemClass
```

Example:
```bash
cd semana_2
javac 49_group_anagrams.java
java -ea Solution
```

### Run all tests

```bash
./run_all_tests.sh
```

Or manually:
```bash
bash run_all_tests.sh
```

## ğŸ“‹ Requirements

- Java JDK 8 or higher
- `javac` compiler
- `java` interpreter

## ğŸ“ Notes

- All files include unit tests in the `main` method
- Solutions are optimized for the best Big O complexity
- Tests use `assert` - run with `java -ea ClassName` to enable assertions
- All problem descriptions are in English
- Problems are organized by week in separate directories
